#!/usr/bin/env node

"use strict";

const argv = require("yargs")
    .option("export", {alias: "e", describe: "If set all modules for the requested language found in root will be parsed and a export.csv will be generated."})
    .option("exportOutput", {default: "export", describe: "The file path to which the export should be written."})
    .option("format", {default: "csv", describe: "The format of the import/export operation. Supported formats are CSV and PO (case-insensitive)."})
    .option("import", {alias: "i", describe: "A CSV file to be imported and to generate code from. Generate elm files will be placed in <importOutput>."})
    .option("importOutput", {default: "import", describe: "The base directory to which the generated code should be written. Subdirectories will be created per language and submodule."})
    .option("genswitch", {alias: "s", describe: "Generates Elm modules containing switches for all given languages."})
    .option("language", {alias: "l", describe: "The language code of the current operation. This should match the subdirectory of the language in root."})
    .option("root", {default: "Translation", describe: "The root to the translation modules. This script expects this directory to contain a subdirectory for each language."})
    .demand("language")
    .boolean(["export"])
    .help()
    .argv;
const Elm = require("./dist/elm.js");
const fs = require("fs-extra");
const path = require("path");
const glob = require("glob");

if (!argv.export && !argv.import && !argv.genswitch) {
    console.error("Please provide import, export or genswitch option");
    process.exit(403);
}

if (argv.exportOutput == "export") {
    argv.exportOutput = argv.exportOutput + "." + argv.format.toLowerCase();
}

const currentDir = process.cwd();

if (argv.export) {
    let fullPath = path.join(currentDir, argv.root, argv.language);
    console.log("Parsing from", fullPath);
    let fileNames = glob.sync(fullPath + "/**/*.elm");
    console.log("└── Found elm module files for export:", fileNames);

    // read all files and store their content in an array
    let fileContents = [];
    fileNames.forEach(function(file) {
        let data = fs.readFileSync(file);
        let content = data.toString();
        fileContents.push(content);
    });

    // pass the array of file contents to our elm worker
    let worker = Elm.Main.worker({
        "languages": [],
        "sources": fileContents,
        "operation": "export",
        "format": argv.format,
    });

    // subscribe to the port to handle completion callback
    worker.ports.exportResult.subscribe(function(resultString) {
        handleExport(resultString);
    });
} else if (argv.import) {
    // ensure that import is a valid file path
    if (!argv.import || argv.import == "" || argv.import == true) {
        console.error("Please provide an import path");
        process.exit(403);
    }

    let pathToImportFile = path.join(currentDir, argv.import);
    if (!fs.existsSync(pathToImportFile)) {
        console.error("Could not find " + argv.format + " file at", pathToImportFile);
        process.exit(403);
    }

    let data = fs.readFileSync(pathToImportFile);
    let csvContent = data.toString();

    let worker = Elm.Main.worker({
        "languages": argv.language.split(","),
        "sources": [csvContent],
        "operation": "import",
        "format": argv.format,
    });

    let importDir = path.join(currentDir, argv.importOutput, argv.root);
    worker.ports.importResult.subscribe(function(resultString) {
        handleImport(resultString, importDir);
    });
} else {
    let fullPath = path.join(currentDir, argv.root);
    console.log("Parsing from", fullPath);
    let fileNames = glob.sync(fullPath + "/Translation/**/{"+argv.language+"}.elm");
    console.log("└── Found elm module files for export:", fileNames);

    // read all files and store their content in an array
    let fileContents = [];
    fileNames.forEach(function(file) {
        let data = fs.readFileSync(file);
        let content = data.toString();
        fileContents.push(content);
    });

    let worker = Elm.Main.worker({
        "sources": fileContents,
        "operation": "genswitch",
        "languages": argv.language.split(","),
        "format": argv.format,
    });

    let importDir = path.join(currentDir, argv.importOutput, argv.root);
    worker.ports.importResult.subscribe(function(resultString) {
        handleImport(resultString, importDir);
    });
}


/**
 * handleExport - Handles the csv string generated by elm and saves it to exportOutput.
 *
 * @param  {String} resultString A CSV string of all translations.
 */
function handleExport(resultString) {
    if (resultString === "") {
        process.exit(500);
    }

    let targetPath = path.join(currentDir, argv.exportOutput);
    fs.writeFileSync(targetPath, resultString);
    console.log("Finished writing csv file to:", targetPath);
}

/**
 * handleImport - Handles the code generated by elm from a CSV file and writes
 * it to argv.importOutput/argv.language.
 *
 * @param  {[[String]]} results A list of (module name, file content) tuples.
 */
function handleImport(results, importDir) {
    fs.ensureDirSync(importDir);
    console.log("Writing elm-files files to:", importDir);
    results.forEach(function(result) {
        let moduleName = result[0];
        if (moduleName.indexOf(argv.root) === 0) {
            moduleName = moduleName.substr(argv.root.length + 1);
        }
        let filePath = path.join(importDir, moduleName + ".elm");
        // we also generate the top-level Translation.elm
        filePath = filePath.replace(/\/(\.elm)$/, "$1");
        fs.ensureDirSync(path.dirname(filePath));
        fs.writeFileSync(filePath, result[1]);
        console.log("└── Finished writing:", filePath);
    });
    console.log("Completed");
}
